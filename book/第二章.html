<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第二章 逆向篇 - mybook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mybook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第二章-windows逆向篇"><a class="header" href="#第二章-windows逆向篇">第二章 Windows逆向篇</a></h1>
<h2 id="21-概述"><a class="header" href="#21-概述">2.1 概述</a></h2>
<p>我们目前已经掌握了基本的C语法，那么目前我们可以做什么呢？就是可以很完美的调用别人写好的函数接口，可不要小看目前这个能力，即使很厉害的程序员最后也是不断的调用写好的函数接口，所以此刻你已经掌握了一个程序员基本的开发能力，但你和那些资深程序员的区别还在于经验不足。不足的地方是你对开发某些业务能使用哪些函数接口，以及出现了函数调用错误或者代码编写错误应该如何排查等问题还很欠缺。所以请不要着急，我们接下来再学习一招逆向手段。</p>
<p>逆向本身不是单单存在计算机行业中，它是一种思维模式。比如吃饭时尝一口就能知道这个菜放了哪些调味品，又比如听一首歌就能知道这个歌用了哪些乐器、韵律是什么样，这些通通都是通过逆向的手段反向得到最初的面貌。</p>
<h2 id="22-逆向工具"><a class="header" href="#22-逆向工具">2.2 逆向工具</a></h2>
<p>在学习编程篇时有相应的工具，同样的在学习逆向时也有相应的工具需要准备，这些优秀的工具都是前人为我们做好方便我们逆向分析的，我们接下来就学会使用这些工具吧。</p>
<h3 id="221-ida-pro"><a class="header" href="#221-ida-pro">2.2.1 IDA Pro</a></h3>
<p>IDA Pro这是一个非常厉害的反汇编工具，其实真正厉害并不是反汇编，而是它里面有一个插件可以实现伪反编译，我是这样理解的。而这个插件呢快捷键是F5，所以也经常被逆向圈的人叫做F5大法。一个小小的F5后，整个逆向的过程变成了读懂伪代码，逆向过程也变的如此简单了，当然这还只是较为简单的逆向，后续我会带大家慢慢接触一些较为复杂的逆向手段，现阶段就先让我们熟悉这款工具吧！</p>
<p>我们可以通过官网下载安装，但是所需的许可证也是一笔昂贵的费用，推荐初学时使用一些前人提供的免费版，至于免费版怎么来的？相信等你学完这个课程就可以明白啦，话不多说我们安装好后就打开这个程序吧！</p>
<blockquote>
<p>IDA Pro 9.0将32位和64位融合成一个版本了，所以低版本的IDA就需要分版本打开相应的程序</p>
</blockquote>
<p>打开一般都会有3秒的延迟和一个弹窗，如果不想要这个延迟和弹窗后续可以通过IDA逆向IDA进而patch掉它，很有意思是不是？</p>
<p>我们打开这个程序后拖拽一个程序放进去，经过漫长的等待后它就会为我们分析出相应的反汇编等数据，这个工具同样很强大，不仅仅只能对exe、dll等这种PE文件进行分析，还可以对很多平台架构的各种文件进行分析，随着IDA版本的更新也会增加对各种文件的分析支持。但是由于我们目标是对Windows平台的逆向，所以我们目前就拖拽一个exe或者dll这种PE文件即可，后续我会为大家讲解PE文件是什么。</p>
<p>我这里拖拽了一个上一章的一个案例放进去，我们可以观察如下：</p>
<p><img src="https://mekey1.github.io/images/2025-02-07-12-07-07-image.png" alt="" /></p>
<p>其中红色框框代表的是IDA分析出的函数有哪些，绿色框框就是主要查看的内容窗口，黄色框框就是运行过程中的一些信息，有点像你用VS运行时下面的调试信息一样。</p>
<p>还记得刚才说的F5吗？我们在红色框框处用Ctrl+F搜索一下main函数，随后按下F5试试看有什么效果？是不是我们之前写的代码都出来了？</p>
<p><img src="https://mekey1.github.io/images/2025-02-07-14-02-38-image.png" alt="" /></p>
<p>我们对比一下我们的源码</p>
<pre><code class="language-c">#include"stdio.h"

struct buyaolian
{
    int x;
    char y;
};

int main()
{
    buyaolian a;
    a.x = 1;
    a.y = 'a';

    printf_s("buyaolian中a的值为%d y的值为%c\n",a.x,a.y);

    return 0;
}
</code></pre>
<p>在这个main函数中看起来好像不大一样啊，不过不用担心，还记得我们之前说过吗？这个工具能做到的是伪反编译，并不能真正的还原成源码，只能做到近似，方便我们分析。</p>
<p>我们首先要清楚我们写的代码是什么，我们无非就是做了一个调用函数printf_s将我们的1和字符a打印输出了一下。那我们看看伪代码是怎么写的首先调用了一个CheckForDebuggerJustMyCode函数，接着调用了一个printf_s，整个过程与我们的代码完全相似。有人说我没有写这个CheckForDebuggerJustMyCode函数啊，这是啥时候加进去的？如果你有这种问题，请想想第一章我们讲过的计算机历史，VS是不是也是很多前人为我们做好的工具，它为了方便我们使用高级语言开发项目，所以底层的细节都替我们处理好了，它除了将你的源码做一系列的编译链接外还增加了很多安全策略等等功能，详细可以看看官方说明（<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/jmc?view=msvc-170">/JMC（“仅我的代码”调试） | Microsoft Learn</a>）。</p>
<p>所以我们就清楚了，真正送给CPU执行的代码其实就是我们反汇编看到的那些代码，我们的源码也不过只是为了方便我们开发而已。CheckForDebuggerJustMyCode函数在我们编译的时候编译器给我加上了，它有属于它自己的功能，像这种类似的函数有很多很多，我们不用关心它，我们真正需要关心的是源码写了什么。</p>
<p>我们发现伪代码中的printf_s输出的是一个1和97，并不是我们的1和a，这是因为ASCII码的存在，也就是我们之前说的类型，97如果不加任何说明没有人知道它是什么，但是我们在输出的时候规定的是按照%c输出，所以就按照ASCII码的规范理解成字符了。请点击97这个数字并按快捷键R看看效果，是不是字符一下子就出来了？</p>
<p>到这里你基本掌握了逆向的小手法了，但是还有很多概念你还没有完全掌握，接下来请允许我再提供关于IDA Pro更多的操作手法，帮助你在以后的逆向道路上走的更远。</p>
<p>请点击内容窗口上方的标签IDA View-A回到我们之前的窗口，按下空格试试效果，整个窗口由图形界面变成了反汇编，像下面这样</p>
<p><img src="https://mekey1.github.io/images/2025-02-07-17-31-47-image.png" alt="" /></p>
<p>我们现在可以更清晰的看到反汇编和地址相关的信息了，我们可以点击Options-&gt;General-&gt;Disassembly中的Number of opcode bytes，随便填写入一个数字，比如填写16，最后点击确定界面如下：</p>
<p><img src="https://mekey1.github.io/images/2025-02-07-17-37-33-image.png" alt="" /></p>
<p>我们发现地址的旁边多出了很多的数字，其实这些数字就是我们之前说的机器码转变成的十六进制形式，而这个IDA通过它的反汇编引擎为我们转换成了后面这种可读性良好的样子，也就是汇编。这些数字有很多名称，有叫硬编码的也有叫Opcode的，以后碰见这种叫法要记住都是在说这种指令数字。关于为什么这种数字就能转换成对应的汇编指令要参考微软的白皮书，这是由更底层的人编写规定的。</p>
<p>接下来按下快捷键G，就可以实现跳转到指定的地址处。按下;可以实现在反汇编窗口写注释。在伪代码窗口按下/可以实现在伪代码窗口加注释。双击目标变量或函数就可以进入该内部的实现。初学者有些一不小心在反汇编窗口按下了/，一下子那些伪代码也跑出来了，想取消也不知道怎么取消。不过不用着急，点击Edit-&gt;Comments-&gt;Delete pseudocode commments 就可以删除啦。基本学会这些就能掌握基本的界面操作了，有想学习更多快捷方式请自行查阅资料进行学习。</p>
<p>IDA除了可以自定义一些设置外，还可以通过添加插件插件的形式实现很多功能。插件的安装方式极其简单，大部分情况下将其放入到IDA的安装目录plugins文件夹下即可，特殊情况请参阅插件提供者说明。像IDA的背景插件，以及二进制的patch插件，再或者二进制比对插件等都是非常好用的功能，可以说就是诸多好用的插件才使得IDA功能变得愈发强大。更多好玩的插件请参照链接：<a href="https://github.com/topics/ida-plugin">ida-plugin · GitHub Topics</a>，里面提供了大量的开源插件，寻找到适合自己的插件将其添加到自己的IDA中吧！</p>
<p>当然在逆向分析过程中除了静态像这样分析代码外，我们还需要通过动态调试的方式得到一些较为复杂的代码分析结果。请点击IDA中No debugger，选择当前Windows调试器Local Windows debugger，这样就将调试器切换好了。当然IDA也支持远程调试，如分析ELF文件等时，我们可以将一个ELF文件放入linux系统中，然后再放入其IDA目录下的linux_server文件，搭建好相关的配置就可以实现远程调试。</p>
<p>调试过程很简单，在指定的汇编窗口或者伪源代码窗口按下F2键，这样断点就已下好，当按下F9运行程序时，程序的代码运行到你下断点的位置就会停下来，这时就可以观察相应的堆栈、寄存器等信息，进而得出一些较为复杂的代码运行情况。如下图我在printf_s处下上断点，当执行到此处时程序就会停下来，再通过按下F7进入函数或F8步过函数实现调试。</p>
<p><img src="https://mekey1.github.io/images/2025-02-10-15-44-24-image.png" alt="" /></p>
<p>相信大家都已经对IDA的基本使用有了一个较为清晰的轮廓，试着将刚才的代码重新编译成release版本，在IDA分析时不要导入PDB文件，再看看IDA的分析结果又是如何？我们会发现IDA几乎很多函数都没有标注出函数名，部分函数能够识别是因为IDA有自己内部编写好的硬编码匹配签名。大部分函数识别不了这才应该是正常的现象，想象一下程序代码都已经通过编译发布出去了，结果里面的各种信息都在，这岂不是一件很危险的事情吗？所以才需要通过逆向的手段，不断研究调试提升自己的逆向功底，进而在茫茫代码中找到真正关键的信息。</p>
<p>除了上述IDA这种分析工具外，像Ghidra、x64dbg等优秀的开源逆向分析工具都非常不错，各有优劣，推荐大家都在github上下载使用一下。</p>
<h3 id="222-cff-explorer"><a class="header" href="#222-cff-explorer">2.2.2 CFF Explorer</a></h3>
<p>这款工具主要是对Windows平台的可执行文件进行结构化分析，上面讲IDA时有提到PE文件，这个就是Windows平台的可执行文件。我们拖拽一个案例放入其中，可以看到这款工具清晰的将文件的各种二进制信息通过PE解析形成可供查看的信息。</p>
<p><img src="https://mekey1.github.io/images/2025-02-10-16-19-45-image.png" alt="" /></p>
<p>之前我们讲过结构体，就是将各种所谓的类型放入其中形成一种新的类型。PE结构其实就是各种结构体的组合，该一系列的结构体可以描绘出整个PE文件的各个数据都代表着什么含义，故该工具通过同样的方式进行解析，详细的PE结构请参考文档<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 格式 - Win32 apps | Microsoft Learn</a></p>
<p>这款工具通过点击左侧不同的选项可以查看相应详细的信息，并在其左侧下方提供了多个功能供其使用，如二进制编辑器、地址转换、UPX脱壳等功能。</p>
<p>后续将带领大家做一款简易的PE解析工具，这里只需要知道这款工具可以帮助我们分析PE结构，在以后的逆向分析中快速找到相应所需数据即可。</p>
<h3 id="223-010-editor"><a class="header" href="#223-010-editor">2.2.3 010 Editor</a></h3>
<p>这款工具主要是进行二进制查看，类似的还有Winhex等工具，而这里主要推荐使用这款工具是因为其脚本库功能十分强大，可以自动进行加解密和格式化文件。我们拖拽一个exe文件放入其中，这款工具会自动识别并且利用其内置的模板存储库进行解析。</p>
<p><img src="https://mekey1.github.io/images/2025-02-18-14-17-43-image.png" alt="" /></p>
<p>我们点击模板-&gt;模板存储库，可以看到有很多的模板库供我们选择使用，在后续学习当中有所需要的可以直接从这里下载使用。另外该程序还提供了脚本功能，有些复杂的加解密可以通过编写相应的脚本实现解密功能。</p>
<p><img src="https://mekey1.github.io/images/2025-02-18-14-19-26-image.png" alt="" /></p>
<h3 id="224-detect-it-easy"><a class="header" href="#224-detect-it-easy">2.2.4 Detect-It-Easy</a></h3>
<p>这款工具主要用来进行查壳，我们刚才已经可以看到通过IDA可以直接反编译出来我们的伪源码，这对于开发人员实在是太可怕了。所以市面上就出现了一堆这种加壳工具，利用反汇编引擎的各种特性使IDA等工具在反编译或者反汇编时出错，使得最终形成的代码根本无法正常阅读；又或者增加各种反调试功能，使其调试器在调试程序时出错，最终呈现的功能就是正常运行程序没有问题，但是对目标程序进行逆向分析时困难重重。</p>
<p>通过这款工具可以很清晰的查询到目标程序加的壳子到底属于哪一类，进而可以直接查询特定壳子的脱壳工具，为我们后续逆向分析提供便利。当然如果查询后发现没有任何壳子也并不代表没有壳，也有一种可能是它加了一种非常见的壳子，使得DIE的特征码未能成功匹对上。</p>
<p>这里我拖拽了一个加了upx壳的程序放入其中，可以看到这款工具帮我们分析出其加的是什么类型的壳子，版本号分别是多少，这样通过相应的脱壳工具就可以进行脱壳处理，可以尝试下将未脱壳的程序放入IDA中分析一下。</p>
<p><img src="https://mekey1.github.io/images/2025-02-18-14-50-53-image.png" alt="" /></p>
<p>除了以上这些工具外还有很多好用的工具，如WireShark、Fakenet、Windbg等等，这些工具就不进行一一介绍了。大家可以直接在github网站中搜索浏览各种新鲜的工具，并阅读README文件尝试安装一下吧。</p>
<h2 id="23-逆向cc"><a class="header" href="#23-逆向cc">2.3 逆向C/C++</a></h2>
<h3 id="231-基本数据类型"><a class="header" href="#231-基本数据类型">2.3.1 基本数据类型</a></h3>
<p>之前一章我们讲解C语法的时候有各种各样的类型，这一节我们将分析各种类型变量在汇编层面到底长什么样子，请将下面代码编写到VS中。</p>
<pre><code class="language-c">#include"stdio.h"

int main()
{
    unsigned int x1 = -10; //无符号数
    int y1 = -10; //有符号数
    char x2 = 97; //字符型
    int y2 = 'a'; //整数型
    bool x3 = false; //布尔型
    bool y3 = true;
    const int x4 = 10; //常量

    return 0;
}
</code></pre>
<p>并像在IDA中那样在如图所示下断点，并开启Windows本地调试器。</p>
<p><img src="https://Mekey1.github.io/images/2025-02-18-16-00-33-image.png" alt="" /></p>
<p>随后在代码窗口处点击右键选择转到反汇编处，便可以清晰的看到我们的源代码最终在汇编层面是什么样子了。</p>
<p><img src="https://mekey1.github.io/images/2025-02-18-16-01-56-image.png" alt="" /></p>
<p>无符号理论上不能为负数，这里我们赋值为-10，发现其与有符号整数-10最终结果是一致的，都是使用的补码形式0xFFFFFFF6h存储的。</p>
<p>字符型我们赋值整数97和整数赋值‘a’结果也是一致的，不同的是char是使用的一个字节byte，int是4个字节dword，这也验证了之前我们说的类型只是一种解释，用于我们解释数据的含义。</p>
<p>布尔类型是按照一字节0或1代替。</p>
<p>常量类型我们发现其与其它类型并无区别，原因是其不可修改属性只是在编译层面，在编译时编译器会帮助我们检查代码中的常量类型，防止我们修改。</p>
<p><img src="https://mekey1.github.io/images/2025-02-18-16-34-20-image.png" alt="" /></p>
<h3 id="232-浮点数"><a class="header" href="#232-浮点数">2.3.2 浮点数</a></h3>
<p>在介绍浮点数汇编之前请先了解一下Streaming SIMD Extensions，在早期时处理器会使用X87指令集，我们可以理解成之前我们通过push pop操作栈的时候，浮点数的运算也有一个独属于它自己的栈，这个栈是用各种寄存器实现的。</p>
<blockquote>
<p>寄存器：可以理解成一种和内存条一样的物理介质，不过其存储的数据十分有限，主要就是用来对数据进行操作</p>
</blockquote>
<p>其中浮点数独特的汇编指令如下，详见微软白皮书开发手册<a href="https://www.intel.cn/content/www/cn/zh/content-details/835781/intel-64-and-ia-32-architectures-software-developer-s-manual-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">英特尔® 64 和 IA-32 体系结构软件开发人员手册 合并卷：1、2A、2B、2C、2D、3A、3B、3C、3D 和 4 (intel.cn)</a></p>
<p><img src="https://mekey1.github.io/images/2025-02-18-17-31-07-image.png" alt="" />接下来我们向上面一样，编写代码并编译查看其反汇编，相关汇编指令的含义以注释的方式写在后面，大家可以尝试自己编译查看反汇编。本节内容并无特别之处，主要就是了解其浮点数有特殊的指令，并在以后的逆向分析中对其能够灵活使用。</p>
<pre><code class="language-c">    int x1 = 2;
00FF5E25  mov         dword ptr [x1],2  //将2赋值给x1
    float x2 = 3.1;
00FF5E2C  movss       xmm0,dword ptr [__real@40466666 (01091EECh)]  //将3.1存储到xmm0寄存器中
00FF5E34  movss       dword ptr [x2],xmm0  //将xmm0寄存器中的值存储到x2中
    float y2 = 4.1;
00FF5E39  movss       xmm0,dword ptr [__real@40833333 (01091F00h)]  //将4.1存储到xmm0寄存器中
00FF5E41  movss       dword ptr [y2],xmm0  //将xmm0寄存器的值存储到y2中

    x2 = (float)x1;
00FF5E46  cvtsi2ss    xmm0,dword ptr [x1]  //将x1转换为浮点数并存入xmm0寄存器中
00FF5E4B  movss       dword ptr [x2],xmm0  //将xxm0寄存器的值存储到x2
    x2 += y2;
00FF5E50  movss       xmm0,dword ptr [x2]  //将x2的值存储到xmm0寄存器中
00FF5E55  addss       xmm0,dword ptr [y2]  //xmm0寄存器的值加上y2的值，将结果存储到xmm0寄存器中
00FF5E5A  movss       dword ptr [x2],xmm0  //将xxm0寄存器的值存储到x2
    x2 -= 1.3;
00FF5E5F  cvtss2sd    xmm0,dword ptr [x2]  //将x2转换为64位的双精度浮点数，并放入xxm0寄存器中
00FF5E64  subsd       xmm0,mmword ptr [__real@3ff4cccccccccccd (01091EF0h)]  //xxm0寄存器的值减去1.3，将结果放入到xmm0寄存器中
00FF5E6C  cvtsd2ss    xmm0,xmm0  //将64位双精度的浮点数xmm0中的值转换为32位的单精度浮点数，并将结果保存到xmm0中
00FF5E70  movss       dword ptr [x2],xmm0  //将xmm0寄存器的值存储到x2中
</code></pre>
<h3 id="233-结构体与联合体"><a class="header" href="#233-结构体与联合体">2.3.3 结构体与联合体</a></h3>
<p>接下来我们学习结构体与联合体汇编，这里需要延伸一个内存对齐的概念。内存对齐是为了提高内存访问速度的一种操作，具体我们可以这样理解，每次内存访问的时候根据不同的硬件设备按照2字节、4字节、8字节等方式进行读取的，所以内存在寻找数据的时候也是按照这样倍数的地址去寻找的数据。</p>
<p>如果你将一个4字节数据放在0-3地址上，它访问0地址就直接取出来了，但是如果放到1-4地址，这样CPU取的时候就需要取两次，先取1-3地址再取4地址，最后拼接成目标的4字节数据。通过对齐可以减少CPU的访问内存次数，进而提高内存访问速度。</p>
<p>了解了内存对齐的概念，我们还要清楚在我们的编译器它会在编译的时候自动的为我们加入了一些对齐的格式，比如我们要编译32位的程序，编译器就自动的给我们对齐的时候安照4字节，我们需要通过一些命令进行修改。接下来请写出下面的代码：</p>
<pre><code class="language-c">#include"stdio.h"
#include&lt;Windows.h&gt;

#pragma pack(1) //告诉编译器按照1字节对齐
typedef struct _Test
{
    char x1;
    int x2;
    char x3[10];
}Test;

int main()
{
    Test array1 = { 0 };
    Test array2 = { 0 };
    array1.x1 = 'a'; 
    array1.x2 = 123;
    strcpy(array1.x3, "abc");

    array2 = array1; //结构体对结构体赋值

    return 0;
}
</code></pre>
<p>通过在return 0处下断点调试到之前反汇编界面，然后点击 调试-&gt;窗口-&gt;内存-&gt;内存1 到如下界面，并在内存窗口处填写&amp;array1查询其内存数据。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-10-55-15-image.png" alt="" /></p>
<p>我们可以看到内存数据的排列顺序也与我们定义的相同，先是1个字节ASCII的‘a’，后面是十六进制的123，最后是一个字符数组“abc”。结构体对结构体的赋值也是通过成员对成员的依次赋值。接下来请将下面代码写下，按照上面的方式再查看一下实际情况。</p>
<pre><code class="language-c">#include"stdio.h"
#include&lt;Windows.h&gt;

typedef union _Test
{
    int x1;
    int x2;
    int x3;
}Test;

int main()
{
    Test array1 = { 0 };
    Test array2 = { 0 };
    
    array1.x1 = 16;
    array1.x2 = 32;
    array1.x3 = 48;

    array2 = array1; //联合体对联合体赋值

    return 0;
}
</code></pre>
<p>通过反汇编查看，联合体实际上只占一块内存，只是对该内存的命名不同，可以叫x1也可以叫x2、x3，实际在操作时都是操作一个整型变量，自然也是值传递。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-11-28-58-image.png" alt="" /></p>
<h3 id="234-多维数组与字符串"><a class="header" href="#234-多维数组与字符串">2.3.4 多维数组与字符串</a></h3>
<p>数组和字符串的案例如下，请将下面代码写出并像上面那样调试。</p>
<pre><code class="language-c">#include"stdio.h"
#include&lt;Windows.h&gt;

int main()
{
    int x1[2][3] = { {1, 2, 3}, {4, 5, 6} };
    int x3[6] = { 1,2,3,4,5,6 };
    int(*x2)[3] = x1;

    const char* y1 = "abcd";
    char y2[] = "dcba";
    y1 = y2;

    return 0;
}
</code></pre>
<p>我们可以清晰的看到多维数组其实底层与一维数组没有什么区别，在赋值的时候实际就是按照一维数组的方式去赋值的，而数组的名称还可以当成指针一样去赋值给其它的变量。</p>
<p>字符串赋值与字符数组赋值区别在于字符串赋值是直接将一个内部定义好的字符串进行赋值，而字符数组赋值是进行单一的字符赋值，最后在其末尾补0达到形成字符串赋值的效果，同样的字符串的名称也可以当做指针一样赋值给其它的变量。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-12-25-05-image.png" alt="" /></p>
<p>本节的主要内容是希望大家在以后的编程当中对数据有个清晰的认识，操作数据时要有内存思维，这样在以后的逆向当中才不会迷失在茫茫数据当中，下一节我们将开始对C语言的各种语法结构进行分析。</p>
<h3 id="235-条件判断"><a class="header" href="#235-条件判断">2.3.5 条件判断</a></h3>
<p>这节将对C语言的条件判断做逆向分析，请将下面的代码写入VS中，并在合适的位置下上断点进行调试。</p>
<pre><code class="language-c">#include"stdio.h"
#include&lt;Windows.h&gt;

int main()
{
    int x = 1;

    if (x &gt; 0)
    {
        printf("x &gt; 0 \n");
    }
    else if (x == 0)
    {
        printf("x = 0 \n");
    }
    else
    {
        printf("x &lt; 0 \n");
    }

    switch (x)
    {
    case 0:
    {
        printf("x = 0\n");
        break;
    }
    case 1:
    {
        printf("x = 1\n");
        break;
    }
    case 2:
    {
        printf("x = 2\n");
        break;
    }
    default:
    {
        printf("default\n");
    }
    }

    switch (x)
    {
    case 0:
    {
        printf("x = 0\n");
        break;
    }
    case 1:
    {
        printf("x = 1\n");
        break;
    }
    case 2:
    {
        printf("x = 2\n");
        break;
    }
    case 3:
    {
        printf("x = 3\n");
        break;
    }
    case 4:
    {
        printf("x = 4\n");
        break;
    }
    case 5:
    {
        printf("x = 5\n");
        break;
    }
    case 6:
    {
        printf("x = 6\n");
        break;
    }
    default:
    {
        printf("default\n");
    }
    }

    return 0;
}
</code></pre>
<p>该代码一共有三部分，前面是对if-else条件语句进行分析，后面是对switch-case进行分析。其中if-else语句相对较为简便，只是判断数据和目标的值，进而选择跳转的位置。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-14-40-01-image.png" alt="" /></p>
<p>switch-case语句在case分支较为少时与if-else类似，都是单个进行判断数据是否与目标值相等，进而选择跳转执行不同的分支。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-14-41-35-image.png" alt="" /></p>
<p>但在case分支数量变多时，编译器会自动生产一张内存表，该表用于记录各分支的偏移，进而通过一个公式实现目标分支的定位。</p>
<p><img src="https://mekey1.github.io/images/2025-02-19-14-44-17-image.png" alt="" /></p>
<h3 id="236-循环结构"><a class="header" href="#236-循环结构">2.3.6 循环结构</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="第一章.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="第三章.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="第一章.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="第三章.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
